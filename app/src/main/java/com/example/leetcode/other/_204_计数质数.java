/*
 * ************************************************************
 * 文件：_204_计数质数.java
 * 模块：app
 * 项目：MyApplication
 * 当前修改时间：2020年12月03日 09:21:15
 * 上次修改时间：2020年12月03日 09:21:15
 * 作者：Havi
 * Copyright (c) 2020
 * ************************************************************
 *
 */

package com.example.leetcode.other;

import static java.lang.Math.sqrt;

public class _204_计数质数 {

    /*
    暴力解法
     */
    public int countPrimes(int n) {
        int count = 0;
        for (int i = 2; i < n; i++) {
            if (isZhiShu(i)) count++;
        }
        return count;
    }

    boolean isZhiShu(int num) {
        boolean result = true;
        for (int i = 2; i < num; i++) {
            if (num%i == 0) {
                result = false;
                break;
            }
        }
        return result;
    }

    /*
    对于每个数n，其实并不需要从2判断到n-1，我们知道，一个数若可以进行因数分解，
    那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)，
    据此，上述代码中并不需要遍历到n-1，遍历到sqrt(n)即可，
    因为若sqrt(n)左侧找不到约数，那么右侧也一定找不到约数
    假如某个数n不是素数，则一定可以分解成x*y形式。
    由此可以推论，n不是素数，则一定可以被某个小于n的数整除。
    而对n来说，最小公因数最大只可能为n的平方根，
    因为假如存在一个大于n平方根的公因数x，则一定存在另一个公因数y＝n/x, y<x。
    从上面的推理可以得出结论，如果n不能被所有小于等于它的平方根的整数整除，则n为素数。
     */

    boolean isZhiShu1(int num) {
        int tmp = (int) Math.sqrt(num);
        for (int i = 2; i <= tmp; i++) {
            if (num%i == 0) {
                return false;
            }
        }
        return true;
    }

    /*
    首先看一个关于质数分布的规律：大于等于5的质数一定和6的倍数相邻。例如5和7，11和13,17和19等等；

证明：令x≥1，将大于等于5的自然数表示如下：
······ 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ······
可以看到，不在6的倍数两侧，即6x两侧的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，
显然，素数要出现只可能出现在6x的相邻两侧。
这里有个题外话，关于孪生素数，有兴趣的道友可以再另行了解一下，由于与我们主题无关，暂且跳过。
这里要注意的一点是，在6的倍数相邻两侧并不是一定就是质数。
此时判断质数可以6个为单元快进，即将方法（2）循环中i++步长加大为6，加快判断速度，原因是，假如要判定的数为n，则n必定是6x-1或6x+1的形式，
对于循环中6i-1，6i，6i+1,6i+2，6i+3，6i+4，其中如果n能被 6i，6i+2，6i+4整除，则n至少得是一个偶数，但是6x-1或6x+1的形式明显是一个奇数，故不成立；
另外，如果n能被6i+3整除，则n至少能被3整除，但是6x能被3整除，故6x-1或6x+1（即n）不可能被3整除，故不成立。综上，循环中只需要考虑6i-1和6i+1的情况，即循环的步长可以定为6，
每次判断循环变量k和k+2的情况即可，理论上讲整体速度应该会是方法（2）的3倍。
     */
    boolean isZhiShu2(int num) {
        //两个较小数另外处理
        if(num ==2|| num==3 )
            return true;
        //不在6的倍数两侧的一定不是质数
        if(num %6!= 1&&num %6!= 5)
            return false;
        int tmp = (int) Math.sqrt( num);
        //在6的倍数两侧的也可能不是质数
        for(int i= 5;i <=tmp; i+=6 )
            if(num %i== 0||num %(i+ 2)==0 )
                return false ;
        //排除所有，剩余的是质数
        return true ;
    }

}
